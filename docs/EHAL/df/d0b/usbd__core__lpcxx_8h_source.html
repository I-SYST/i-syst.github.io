<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EHAL: EHAL/ARM/NXP/include/usbd_core_lpcxx.h Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../I-SYST_Logo180.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EHAL
   &#160;<span id="projectnumber">0</span>
   </div>
   <div id="projectbrief">Embedded Hardware Abstraction Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('df/d0b/usbd__core__lpcxx_8h_source.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">usbd_core_lpcxx.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * lpcusbd_core.h</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * USBD stack Core API functions structure.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">This module exposes functions which interact directly with USB device stack&#39;s core layer.</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">The application layer uses this component when it has to implement custom class function</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">driver or standard class function driver which is not part of the current USB device stack.</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">The functions exposed by this interface are to register class specific EP0 handlers and</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">corresponding utility functions to manipulate EP0 state machine of the stack. This</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">interface also exposes function to register custom endpoint interrupt handler.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> *  Created on: Nov 9, 2014</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *      Author: hoan</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#ifndef __LPCUSBD_CORE_H__</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#define __LPCUSBD_CORE_H__</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;usb/usb_def.h&quot;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#define USB_FS_MAX_BULK_PACKET      64</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#define USB_HS_MAX_BULK_PACKET      512</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#define USB_MAX_BULK_PACKET         USB_FS_MAX_BULK_PACKET</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">void</span>* USBD_HANDLE_T;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">// USBD setup request and endpoint event handler type.</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">// The application layer should define the custom class&#39;s EP0 handler with</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">// function signature. The stack calls all the registered class handlers on</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">// any EP0 event before going through default handling of the event. This</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">// gives the class handlers to implement class specific request handlers and</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">// also to override the default stack handling for a particular event targeted</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// to the interface. If an event is not handled by the callback the function</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// should return ERR_USBD_UNHANDLED. For all other return codes the stack</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// assumes that callback has taken care of the event and hence will not process</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// the event any further and issues a STALL condition on EP0 indicating error</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// to the host.</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// For endpoint interrupt handler the return value is ignored by the stack.</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// Parameters:</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">//      [in]    data    Pointer to the data which will be passed when callback function is called by the stack.</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">//      [in]    event   Type of endpoint event. See USBD_EVENT_T for more details.</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">// Returns:</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">//      The call back should returns ErrorCode_t type to indicate success or error condition.</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">//      Return values:</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">//      LPC_OK  On success.</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">//      ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">//      ERR_USBD_xxx    For other error conditions.</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="keyword">typedef</span> uint32_t (*USB_EP_HANDLER_T)(USBD_HANDLE_T hUsb, <span class="keywordtype">void</span> *data, uint32_t event);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#pragma pack(push, 1)</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno"><a class="line" href="../../d0/d4b/struct_u_s_b___s_e_t_u_p___p_a_c_k_e_t.html">   55</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    uint8_t bmRequestType;          <span class="comment">// Characteristics of request:</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                    <span class="comment">// D7: Data transfer direction</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                    <span class="comment">//      0 = Host-to-device</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                    <span class="comment">//      1 = Device-to-host</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                    <span class="comment">// D6...5: Type</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                    <span class="comment">//      0 = Standard</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                                    <span class="comment">//      1 = Class</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                                    <span class="comment">//      2 = Vendor</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                                    <span class="comment">//      3 = Reserved</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                    <span class="comment">// D4...0: Recipient</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                    <span class="comment">//      0 = Device</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                    <span class="comment">//      1 = Interface</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                    <span class="comment">//      2 = Endpoint</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                    <span class="comment">//      3 = Other</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                    <span class="comment">//      4...31 = Reserved</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    uint8_t bRequest;               <span class="comment">// Specific request (refer to Table 9-3)</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    uint16_t wValue;                <span class="comment">// Word-sized field that varies according to request</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    uint16_t wIndex;                <span class="comment">// Index or Offset</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                                    <span class="comment">// Word-sized field that varies according to request;</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                                    <span class="comment">// typically used to pass an index or offset</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    uint16_t wLength;               <span class="comment">// Number of bytes to transfer if there is a Data stage</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;} <a class="code" href="../../d0/d4b/struct_u_s_b___s_e_t_u_p___p_a_c_k_e_t.html">USB_SETUP_PACKET</a>;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html">   79</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// Function to register class specific EP0 event handler with USB device stack.</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="comment">// The application layer uses this function when it has to register the custom</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// class&#39;s EP0 handler. The stack calls all the registered class handlers on any</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="comment">// EP0 event before going through default handling of the event. This gives the</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">// class handlers to implement class specific request handlers and also to</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// override the default stack handling for a particular event targeted to the</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="comment">// interface. Check USB_EP_HANDLER_T for more details on how the callback</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">// function should be implemented. Also application layer could use this</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// function to register EP0 handler which responds to vendor specific requests.</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">//Parameters:</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="comment">//      [in]    pfn     Class specific EP0 handler function.</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="comment">//      [in]    data    Pointer to the data which will be passed when callback</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="comment">//                      function is called by the stack.</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="comment">//      Returns ErrorCode_t type to indicate success or error condition.</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="comment">// Return values:</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">//      LPC_OK  On success</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="comment">//      ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)    The number of class handlers registered is greater than the number of handlers allowed by the stack.</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    uint32_t (*RegisterClassHandler )(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, <span class="keywordtype">void</span> *data);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// Function to register interrupt/event handler for the requested endpoint</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="comment">// with USB device stack.</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="comment">// The application layer uses this function to register the endpoint event handler.</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// The stack calls all the registered endpoint handlers when</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="comment">// USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="comment">// USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint. Check USB_EP_HANDLER_T</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="comment">// for more details on how the callback function should be implemented.</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="comment">// By default endpoint _NAK events are not enabled. Application should call</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="comment">// USBD_HW_API_T::EnableEvent for the corresponding endpoint.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">//      [in]    hUsb        Handle to the USB device stack.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="comment">//      [in]    ep_index    Endpoint index. Computed as</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="comment">//                          For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="comment">//                          For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">//      [in]    pfn         Endpoint event handler function.</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">//      [in]    data        Pointer to the data which will be passed when callback function</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="comment">//                          is called by the stack.</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="comment">//      Returns ErrorCode_t type to indicate success or error condition.</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">//      Return values:</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">//      LPC_OK  On success</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">//      ERR_API_INVALID_PARAM2  ep_index is outside the boundary</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">//      ( &lt; 2 * USBD_API_INIT_PARAM_T::max_num_ep).</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    uint32_t (*RegisterEpHandler )(USBD_HANDLE_T hUsb, uint32_t ep_index,</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                   USB_EP_HANDLER_T pfn, <span class="keywordtype">void</span> *data);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="comment">// Function to set EP0 state machine in setup state.</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to set the</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="comment">// EP0 state machine in setup state. This function will read the setup packet</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">// received from USB host into stack&#39;s buffer.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="comment">// This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack&#39;s standard handlers through callback interface exposed by the stack.</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    void (*SetupStage )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">// Function to set EP0 state machine in data_in state.</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to set the</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// EP0 state machine in data_in state. This function will write the data</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">// present in EP0Data buffer to EP0 FIFO for transmission to host.</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">//  This interface is provided to users to invoke this function in other</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="comment">//  scenarios which are not handle by current stack. In most user applications</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="comment">//  this function is not called directly.Also this function can be used by users</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">//  who are selectively modifying the USB device stack&#39;s standard handlers</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="comment">//  through callback interface exposed by the stack.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    void (*DataInStage )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="comment">// Function to set EP0 state machine in data_out state.</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to set the</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="comment">// EP0 state machine in data_out state. This function will read the control</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">// data (EP0 out packets) received from USB host into EP0Data buffer.</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="comment">//  This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack&#39;s standard handlers through callback interface exposed by the stack.</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    void (*DataOutStage )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="comment">// Function to set EP0 state machine in status_in state.</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to set</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="comment">// the EP0 state machine in status_in state. This function will send zero</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">// length IN packet on EP0 to host, indicating positive status.</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">//  This interface is provided to users to invoke this function in other</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="comment">//  scenarios which are not handle by current stack. In most user applications</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="comment">//  this function is not called directly.Also this function can be used by</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="comment">//  users who are selectively modifying the USB device stack&#39;s standard</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">//  handlers through callback interface exposed by the stack.</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    void (*StatusInStage )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="comment">// Function to set EP0 state machine in status_out state.</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to set</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="comment">// the EP0 state machine in status_out state. This function will read the</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">// zero length OUT packet received from USB host on EP0.</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">//  This interface is provided to users to invoke this function in other</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">//  scenarios which are not handle by current stack. In most user applications</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="comment">//  this function is not called directly.Also this function can be used by</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="comment">//  users who are selectively modifying the USB device stack&#39;s standard</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="comment">//  handlers through callback interface exposed by the stack.</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    void (*StatusOutStage )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="comment">// Function to set EP0 state machine in stall state.</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="comment">// This function is called by USB stack and the application layer to generate</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">// STALL signaling on EP0 endpoint. This function will also reset the EP0</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">// Data buffer.</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="comment">// Note:</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="comment">//  This interface is provided to users to invoke this function in other</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="comment">//  scenarios which are not handle by current stack. In most user applications</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="comment">//  this function is not called directly.Also this function can be used by</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="comment">//  users who are selectively modifying the USB device stack&#39;s standard</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="comment">//  handlers through callback interface exposed by the stack.</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="comment">// Parameters:</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="comment">//      [in]    hUsb    Handle to the USB device stack.</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">// Returns:</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">//      Nothing.</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    void (*StallEp0 )(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;} <a class="code" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html">USBD_CORE_API_T</a>;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">// Undocumented structre require by API</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="preprocessor">#define USB_FULL_SPEED    0</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="preprocessor">#define USB_HIGH_SPEED    1</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="preprocessor">#ifndef USB_MAX_EP_NUM</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="preprocessor">#define USB_MAX_EP_NUM      10</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="preprocessor">#ifndef USB_MAX_IF_NUM</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="preprocessor">#define USB_MAX_IF_NUM      5</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">/* USB Endpoint Data Structure */</span></div><div class="line"><a name="l00243"></a><span class="lineno"><a class="line" href="../../d1/d51/struct___u_s_b___e_p___d_a_t_a.html">  243</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d51/struct___u_s_b___e_p___d_a_t_a.html">_USB_EP_DATA</a></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;{</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  uint8_t  *pData;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  uint16_t   Count;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  uint16_t pad0;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;} <a class="code" href="../../d1/d51/struct___u_s_b___e_p___d_a_t_a.html">USB_EP_DATA</a>;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">/* USB core controller data structure */</span></div><div class="line"><a name="l00252"></a><span class="lineno"><a class="line" href="../../d4/da3/struct___u_s_b___c_o_r_e___c_t_r_l___t.html">  252</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/da3/struct___u_s_b___c_o_r_e___c_t_r_l___t.html">_USB_CORE_CTRL_T</a></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="comment">/* override-able function pointers ~ c++ style virtual functions*/</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  uint32_t (*USB_EvtSetupHandler)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  uint32_t (*USB_EvtOutHandler)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  uint32_t (*USB_ReqVendor)(USBD_HANDLE_T hUsb, uint32_t param1);</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  uint32_t (*USB_ReqGetStatus)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  uint32_t (*USB_ReqGetDescriptor)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  uint32_t (*USB_ReqGetConfiguration)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  uint32_t (*USB_ReqSetConfiguration)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  uint32_t (*USB_ReqGetInterface)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  uint32_t (*USB_ReqSetInterface)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  uint32_t (*USB_ReqSetClrFeature)(USBD_HANDLE_T hUsb, uint32_t param1);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">/* USB Device Events Callback Functions */</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  uint32_t (*USB_Reset_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  uint32_t (*USB_Suspend_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  uint32_t (*USB_Resume_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  uint32_t (*USB_SOF_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  uint32_t (*USB_Power_Event)(USBD_HANDLE_T hUsb, uint32_t param1);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  uint32_t (*USB_Error_Event)(USBD_HANDLE_T hUsb, uint32_t param1);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  uint32_t (*USB_WakeUpCfg)(USBD_HANDLE_T hUsb, uint32_t param1);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="comment">/* USB Core Events Callback Functions */</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  uint32_t (*USB_Configure_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  uint32_t (*USB_Interface_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  uint32_t (*USB_Feature_Event)(USBD_HANDLE_T hUsb);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">/* cache and MMU translation functions */</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  uint32_t (* virt_to_phys)(<span class="keywordtype">void</span>* vaddr);</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  void (* cache_flush)(uint32_t* start_adr, uint32_t* end_adr);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="comment">/* event handlers for endpoints. */</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  uint32_t (*ep_event_hdlr[2 * USB_MAX_EP_NUM])(USBD_HANDLE_T hUsb, <span class="keywordtype">void</span>* data, uint32_t event);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="keywordtype">void</span>*  ep_hdlr_data[2 * USB_MAX_EP_NUM];</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <span class="comment">/* USB class handlers */</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  uint32_t (*ep0_hdlr_cb[USB_MAX_IF_NUM])(USBD_HANDLE_T hUsb, <span class="keywordtype">void</span>* data, uint32_t event);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="keywordtype">void</span>*  ep0_cb_data[USB_MAX_IF_NUM];</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  uint8_t num_ep0_hdlrs;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="comment">/* USB Core data Variables */</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  uint8_t max_num_ep; <span class="comment">/* max number of endpoints supported by the HW */</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  uint8_t device_speed;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  uint8_t  num_interfaces;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  uint8_t  device_addr;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  uint8_t  config_value;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  uint16_t device_status;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  uint8_t *device_desc;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  uint8_t *string_desc;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  uint8_t *full_speed_desc;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  uint8_t *high_speed_desc;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  uint8_t *device_qualifier;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  uint32_t ep_mask;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  uint32_t ep_halt;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  uint32_t ep_stall;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  uint8_t  alt_setting[USB_MAX_IF_NUM];</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <span class="comment">/* HW driver data pointer */</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="keywordtype">void</span>* hw_data;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="comment">/* USB Endpoint 0 Data Info */</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <a class="code" href="../../d1/d51/struct___u_s_b___e_p___d_a_t_a.html">USB_EP_DATA</a> EP0Data;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">/* USB Endpoint 0 Buffer */</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  uint8_t  EP0Buf[64];</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="comment">/* USB Setup Packet */</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <a class="code" href="../../d0/d4b/struct_u_s_b___s_e_t_u_p___p_a_c_k_e_t.html">USB_SETUP_PACKET</a> SetupPacket;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;} <a class="code" href="../../d4/da3/struct___u_s_b___c_o_r_e___c_t_r_l___t.html">USB_CORE_CTRL_T</a>;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="preprocessor">#pragma pack(pop)</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">#endif // __LPCUSBD_CORE_H__</span></div><div class="ttc" id="struct_u_s_b___s_e_t_u_p___p_a_c_k_e_t_html"><div class="ttname"><a href="../../d0/d4b/struct_u_s_b___s_e_t_u_p___p_a_c_k_e_t.html">USB_SETUP_PACKET</a></div><div class="ttdef"><b>Definition:</b> <a href="../../df/d0b/usbd__core__lpcxx_8h_source.html#l00055">usbd_core_lpcxx.h:55</a></div></div>
<div class="ttc" id="struct___u_s_b___c_o_r_e___c_t_r_l___t_html"><div class="ttname"><a href="../../d4/da3/struct___u_s_b___c_o_r_e___c_t_r_l___t.html">_USB_CORE_CTRL_T</a></div><div class="ttdef"><b>Definition:</b> <a href="../../df/d0b/usbd__core__lpcxx_8h_source.html#l00252">usbd_core_lpcxx.h:252</a></div></div>
<div class="ttc" id="struct_u_s_b_d___c_o_r_e___a_p_i___t_html"><div class="ttname"><a href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html">USBD_CORE_API_T</a></div><div class="ttdef"><b>Definition:</b> <a href="../../df/d0b/usbd__core__lpcxx_8h_source.html#l00079">usbd_core_lpcxx.h:79</a></div></div>
<div class="ttc" id="struct___u_s_b___e_p___d_a_t_a_html"><div class="ttname"><a href="../../d1/d51/struct___u_s_b___e_p___d_a_t_a.html">_USB_EP_DATA</a></div><div class="ttdef"><b>Definition:</b> <a href="../../df/d0b/usbd__core__lpcxx_8h_source.html#l00243">usbd_core_lpcxx.h:243</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_85008b6458b23c54b0bfe149a14fcbf1.html">EHAL</a></li><li class="navelem"><a class="el" href="../../dir_67d5c41193a20b9df0e87028f1102a8e.html">ARM</a></li><li class="navelem"><a class="el" href="../../dir_da2f25404dadad644d8fb488a8ca30c5.html">NXP</a></li><li class="navelem"><a class="el" href="../../dir_190362a162d311714fa4a17a0efcacdf.html">include</a></li><li class="navelem"><b>usbd_core_lpcxx.h</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
